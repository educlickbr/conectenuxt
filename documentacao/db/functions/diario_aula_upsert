CREATE OR REPLACE FUNCTION public.diario_aula_upsert(p_data jsonb, p_id_empresa uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_id uuid;
    v_registro_salvo public.diario_aula;
    v_user_id uuid;
BEGIN
    v_id := coalesce(nullif(p_data ->> 'id', '')::uuid, gen_random_uuid());
    v_user_id := (p_data ->> 'id_usuario')::uuid;

    INSERT INTO public.diario_aula (
        id, 
        id_empresa, 
        id_turma, 
        id_componente, 
        data, 
        conteudo, 
        metodologia, 
        tarefa_casa, 
        id_plano_aula_item, -- NEW FIELD
        registrado_por, 
        registrado_em
    )
    VALUES (
        v_id,
        p_id_empresa,
        (p_data ->> 'id_turma')::uuid,
        (p_data ->> 'id_componente')::uuid,
        (p_data ->> 'data')::date,
        (p_data ->> 'conteudo'),
        (p_data ->> 'metodologia'),
        (p_data ->> 'tarefa_casa'),
        (p_data ->> 'id_plano_aula_item')::uuid, -- NEW FIELD
        v_user_id,
        now()
    )
    ON CONFLICT (id) DO UPDATE 
    SET 
        id_turma = EXCLUDED.id_turma,
        id_componente = EXCLUDED.id_componente,
        data = EXCLUDED.data,
        conteudo = EXCLUDED.conteudo,
        metodologia = EXCLUDED.metodologia,
        tarefa_casa = EXCLUDED.tarefa_casa,
        id_plano_aula_item = EXCLUDED.id_plano_aula_item, -- NEW FIELD
        registrado_por = v_user_id
    WHERE public.diario_aula.id_empresa = p_id_empresa
    RETURNING * INTO v_registro_salvo;

    RETURN to_jsonb(v_registro_salvo);
END;
$function$


CREATE OR REPLACE FUNCTION public.diario_presenca_get_por_turma(p_id_empresa uuid, p_id_turma uuid, p_data date, p_id_componente uuid DEFAULT NULL::uuid)
 RETURNS TABLE(id_matricula uuid, aluno_nome text, aluno_avatar text, turma_nome text, escola_nome text, turno_nome text, ano_etapa_nome text, id_presenca uuid, presente boolean, observacao text, data_presenca date, registrado_em timestamp with time zone, status_matricula text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        m.id AS id_matricula,
        u.nome_completo AS aluno_nome,
        NULL::text AS aluno_avatar,
        
        -- Joining Context Data
        c.nome AS turma_nome, -- Correct: Using nome from classe
        e.nome AS escola_nome,
        he.periodo::text AS turno_nome,
        ae.nome AS ano_etapa_nome,
        
        -- Presence Data
        dp.id AS id_presenca,
        dp.presente,
        dp.observacao,
        dp.data AS data_presenca,
        dp.registrado_em,
        
        m.status AS status_matricula
    FROM
        public.matricula_turma mt
    JOIN
        public.matriculas m ON m.id = mt.id_matricula
    JOIN
        public.user_expandido u ON u.id = m.id_aluno
    JOIN
        public.turmas t ON t.id = mt.id_turma
    JOIN
        public.classe c ON c.id = t.id_classe -- JOIN added
    JOIN
        public.escolas e ON e.id = t.id_escola
    LEFT JOIN
        public.horarios_escola he ON he.id = t.id_horario
    JOIN
        public.ano_etapa ae ON ae.id = t.id_ano_etapa

    -- Left Join Presence
    LEFT JOIN
        public.diario_presenca dp ON
            dp.id_matricula = m.id
            AND dp.id_turma = p_id_turma
            AND dp.data = p_data
            AND (
                (p_id_componente IS NULL AND dp.id_componente IS NULL) OR
                (dp.id_componente = p_id_componente)
            )

    WHERE
        mt.id_empresa = p_id_empresa
        AND mt.id_turma = p_id_turma
        AND mt.status = 'ativa'
        AND m.status = 'ativa'
        AND u.soft_delete IS FALSE
        
    ORDER BY
        u.nome_completo ASC;
END;
$function$


CREATE OR REPLACE FUNCTION public.diario_presenca_upsert_batch(p_payload jsonb, p_id_empresa uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_item jsonb;
    v_count integer := 0;
    v_user_id uuid;
BEGIN
    -- Iterate over the array
    FOR v_item IN SELECT * FROM jsonb_array_elements(p_payload)
    LOOP
        v_user_id := (v_item ->> 'id_usuario')::uuid;

        INSERT INTO public.diario_presenca (
            id,
            id_empresa,
            id_matricula,
            id_turma,
            id_componente,
            data,
            presente,
            observacao,
            registrado_por,
            registrado_em
        )
        VALUES (
            coalesce(nullif(v_item ->> 'id', '')::uuid, gen_random_uuid()),
            p_id_empresa,
            (v_item ->> 'id_matricula')::uuid,
            (v_item ->> 'id_turma')::uuid,
            (v_item ->> 'id_componente')::uuid,
            (v_item ->> 'data')::date,
            coalesce((v_item ->> 'presente')::boolean, false),
            (v_item ->> 'observacao'),
            v_user_id,
            now()
        )
        ON CONFLICT (id) DO UPDATE
        SET
            presente = EXCLUDED.presente,
            observacao = EXCLUDED.observacao,
            registrado_por = v_user_id
        WHERE public.diario_presenca.id_empresa = p_id_empresa;

        -- Alternatively we could conflict on unique index (matricula, turma, date, componente) 
        -- but ID logic is safer if provided by frontend.
        
        v_count := v_count + 1;
    END LOOP;

    RETURN jsonb_build_object('status', 'success', 'processed_count', v_count);
END;
$function$


CREATE OR REPLACE FUNCTION public.diario_aula_get_paginado(p_id_empresa uuid, p_pagina integer DEFAULT 1, p_limite_itens_pagina integer DEFAULT 10, p_id_turma uuid DEFAULT NULL::uuid, p_id_componente uuid DEFAULT NULL::uuid, p_data_inicio date DEFAULT NULL::date, p_data_fim date DEFAULT NULL::date)
 RETURNS json
 LANGUAGE plpgsql
 STABLE
AS $function$
DECLARE
    v_offset integer;
    v_total_itens integer;
    v_total_paginas integer;
    v_itens json;
BEGIN
    v_offset := (p_pagina - 1) * p_limite_itens_pagina;

    SELECT COUNT(*) INTO v_total_itens
    FROM public.diario_aula d
    WHERE d.id_empresa = p_id_empresa
      AND (p_id_turma IS NULL OR d.id_turma = p_id_turma)
      AND (p_id_componente IS NULL OR d.id_componente = p_id_componente)
      AND (p_data_inicio IS NULL OR d.data >= p_data_inicio)
      AND (p_data_fim IS NULL OR d.data <= p_data_fim);

    IF p_limite_itens_pagina > 0 THEN
        v_total_paginas := CEIL(v_total_itens::numeric / p_limite_itens_pagina);
    ELSE
        v_total_paginas := 0; 
    END IF;

    SELECT COALESCE(json_agg(t), '[]'::json) INTO v_itens
    FROM (
        SELECT 
            d.*,
            u.nome_completo as professor_nome,
            c.nome as componente_nome,
            -- Plan Info
            p.titulo as plano_titulo,
            pi.aula_numero as plano_aula_numero
        FROM public.diario_aula d
        LEFT JOIN public.user_expandido u ON u.id = d.registrado_por
        LEFT JOIN public.componente c ON c.uuid = d.id_componente
        LEFT JOIN public.pl_plano_de_aulas_itens pi ON pi.id = d.id_plano_aula_item
        LEFT JOIN public.pl_plano_de_aulas p ON p.id = pi.id_plano_de_aula
        WHERE d.id_empresa = p_id_empresa
          AND (p_id_turma IS NULL OR d.id_turma = p_id_turma)
          AND (p_id_componente IS NULL OR d.id_componente = p_id_componente)
          AND (p_data_inicio IS NULL OR d.data >= p_data_inicio)
          AND (p_data_fim IS NULL OR d.data <= p_data_fim)
        ORDER BY d.data DESC, d.registrado_em DESC
        LIMIT p_limite_itens_pagina
        OFFSET v_offset
    ) t;

    RETURN json_build_object(
        'qtd_itens', v_total_itens,
        'qtd_paginas', v_total_paginas,
        'itens', v_itens
    );
END;
$function$
